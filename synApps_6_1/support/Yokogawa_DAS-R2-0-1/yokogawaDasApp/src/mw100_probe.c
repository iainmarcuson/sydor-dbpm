#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <unistd.h>

#include <netinet/in.h>
#include <arpa/inet.h>



struct module
{
  // raw information
  char set_message[14];
  char status_message[14];
  char error_message[14];

  char module_string[14];

  // broken-out information
  int use_flag;
  // 110 = analog input: ADC
  // 112 = analog input: strain gauge
  // 114 = integer digital input: pulse counting
  // 115 = binary digital input: level measurement
  // 120 = analog output: DAC
  // 125 = binary digital output: relay
  int model; // 110, 112, 114, 115, 120, 125, 0 means empty
  //  int error; // 1=RomError:, 2=CalError:, 3=SlotError:
  char code[4]; 
  int speed; // 0=Low, 1=Medium, 2=High
  int number; // currently: 4, 6, 8, 10, 30
};


char *location = "$(YOKOGAWA_DAS)/yokogawaDasApp/Db";;

char *ip_address = NULL;
char *prefix = NULL;
char *dau = NULL;
char *handle = NULL;

  
void print_sf(FILE *fptr_subst, FILE *fptr_req, struct module *modules)
{
  int i, m;
 
  fprintf( fptr_subst, "# this file was autogenerated by mw100_probe\n\n");
  fprintf( fptr_req, "# this file was autogenerated by mw100_probe\n\n");
  
  fprintf( fptr_subst,
           "file \"%s/MW100_system.db\"\n"
           "{\n"
           "pattern\n"
           "{ P, DAU, HANDLE }\n"
           "{ \"%s\", \"%s\", \"%s\" }\n"
           "}\n"
           "\n",
           location, prefix, dau, handle);
  
  
  fprintf( fptr_subst,
           "file \"%s/MW100_communication_channel.db\"\n"
           "{\n"
           "pattern\n"
           "{ P, DAU, HANDLE, ADDRESS }\n", location);
  for( i = 1; i <= 60; i++)
    {
      fprintf( fptr_subst, "{ \"%s\", \"%s\", \"%s\", \"C%03d\" }\n",
               prefix, dau, handle, i);
      fprintf( fptr_req, "%s%s:C%03d:Label\n", prefix, dau, i);
    }
  fprintf( fptr_subst, "}\n\n");

  fprintf( fptr_subst,
           "file \"%s/MW100_constant_channel.db\"\n"
           "{\n"
           "pattern\n"
           "{ P, DAU, HANDLE, ADDRESS }\n", location);
  for( i = 1; i <= 60; i++)
    {
      fprintf( fptr_subst, "{ \"%s\", \"%s\", \"%s\", \"K%02d\" }\n",
               prefix, dau, handle, i);
      fprintf( fptr_req, "%s%s:K%02d:Label\n", prefix, dau, i);
    }
  fprintf( fptr_subst, "}\n\n");

  fprintf( fptr_subst,
           "file \"%s/MW100_calculation_channel.db\"\n"
           "{\n"
           "pattern\n"
           "{ P, DAU, HANDLE, ADDRESS }\n", location);
  for( i = 1; i <= 60; i++)
    {
      fprintf( fptr_subst, "{ \"%s\", \"%s\", \"%s\", \"A%03d\" }\n",
               prefix, dau, handle, i);
      fprintf( fptr_req, "%s%s:A%03d:Label\n", prefix, dau, i);
    }
  fprintf( fptr_subst, "}\n\n");

  for( m = 0; m < 6; m++)
    {
      if( !modules[m].use_flag)
        continue;

      fprintf( fptr_subst,
               "file \"%s/MW100_MX%d_channel.db\"\n"
               "{\n"
               "pattern\n"
               "{ P, DAU, HANDLE, ADDRESS }\n", location, modules[m].model);
      for( i = 1; i <= modules[m].number; i++)
        {
          fprintf( fptr_subst, "{ \"%s\", \"%s\", \"%s\", \"%03d\" }\n",
                   prefix, dau, handle, i + m*10);
          fprintf( fptr_req, "%s%s:%03d:Label\n", prefix, dau, i + m*10);
        }
      fprintf( fptr_subst, "}\n\n");

    }
  
  
}



static int socket_connect(int *sockfd, char *address)
{
  int result;
  int count;
  
  int sfd;
  struct sockaddr_in r_addr;
  char buffer[1024];

  sfd = socket(AF_INET, SOCK_STREAM, 0);
  bzero( &r_addr, sizeof(r_addr) );
  r_addr.sin_family = AF_INET;
  r_addr.sin_port = htons(34318);
  if( !inet_aton( address, &(r_addr.sin_addr)) )
    {
      return 1;
    }
  
  result = connect(sfd, (struct sockaddr *)&r_addr, 
                   sizeof(r_addr) );
  // change this!
  if( result == -1)
    return 1;

  if( (count = read( sfd, buffer, 1023)) <= 0)
    return 1;
  buffer[count] = '\0';

  
  // initial E0
  if( strcmp( buffer, "E0\r\n"))
    {
      puts("Can't read.");
      return 1;
    }

  *sockfd = sfd;
  
  return 0;
}


static int ascii_reader( int sockfd, char *cmd, char *buffer, int bufflen )
{
  int len, addlen;
  int flag;

  int init_flag;
  
  init_flag = 1;
  
  flag = 1;
  len = 0;

  write( sockfd, cmd, strlen(cmd) );
  while( (addlen = read( sockfd, buffer + len, bufflen - len - 1)) > 0)
    {
      len += addlen;

      //      printf("%s", dq->inbuffer); fflush(stdout);
      if( len > 4)
        {
          if( init_flag)
            {
              if( strncmp( buffer, "EA\r\n", 4) )
                break;
              init_flag = 0;
            }
          if( (buffer[len-4] == 'E') && (buffer[len-3] == 'N') &&
              (buffer[len-2] == '\r') && (buffer[len-1] == '\n') )
            {
              flag = 0;
              break;
            }
        }
    }
  buffer[len] = '\0';

  return flag;
}


int get_modules( int sockfd, struct module *modules)
{
  char *ptr;

  int which;

  char *c;
  int i,j;

  char buffer[1024];

  if( ascii_reader( sockfd, "CF0\r\n", buffer, 1024) )
    return 1;

  ptr = buffer;
  ptr += 4;
  while( *ptr != 'E')
    {
      which = *ptr - '0';
      ptr += 4;

      c = modules[which].set_message;
      for( i = 0; i < 13; i++)
        *(c++) = *(ptr++);
      *c = '\0';
      ptr += 3;

      c = modules[which].status_message;
      for( i = 0; i < 13; i++)
        *(c++) = *(ptr++);
      *c = '\0';
      ptr += 1;

      c = modules[which].error_message;
      while( *ptr != '\r')
        *(c++) = *(ptr++);
      *c = '\0';
      ptr += 2;
    }

  for( i = 0; i < 6; i++)
    {
      modules[i].use_flag = 0;

      // the strings have to match
      if( strcmp( modules[i].set_message, modules[i].status_message ) )
        continue;
      // need no errors
      if( modules[i].error_message[0] != '\0')
        continue;
      if( !strcmp( modules[i].set_message, "-------------") )
        continue;

      modules[i].use_flag = 1;
      strcpy( modules[i].module_string, modules[i].set_message );
      
      // the dash will halt the conversion
      ptr = modules[i].module_string + 2;
      modules[i].model = atoi(ptr);
      ptr += 4;

      c = modules[i].code;
      for( j = 0; j < 3; j++)
        *(c++) = *(ptr++);
      *c = '\0';
      ptr++;

      switch( *ptr)
        {
        case 'L':
          modules[i].speed = 0;
          break;
        case 'M':
          modules[i].speed = 1;
          break;
        case 'H':
          modules[i].speed = 2;
          break;
        default:
          modules[i].speed = -1;
        }
      ptr++;
      
      modules[i].number = atoi(ptr);
    }
  
  return 0;
}



int main( int argc, char *argv[])
{
  FILE *fptr_subst, *fptr_req;

  struct module modules[6]; // only 6 possible

  int sockfd;

  int i;
  
  if( argc != 5)
    {
      puts("mw100_probe (IP address) (P) (DAU) (HANDLE)");
      puts("Probes a Yokogawa MW100 at supplied IP address, and generates EPICS files.\n");

      puts("It will create a substitutions file called \"auto_mw100.substitutions\" and");
      puts("an autosave file called \"auto_mw100.req\" in the current directory.");
      puts("The P, DAU, and HANDLE values correspond to macro values in the MW100 database");
      puts("files, and are used in the generated substitutions and autosave files.  The");
      puts("locations to the database files are given as a relative path from an");
      puts("environment variable, called YOKOGAWA_DAS (up to user to make sure it exists).");
      return 0;
    }

  sockfd = -1;

  ip_address = strdup(argv[1]);
  prefix = strdup(argv[2]);
  dau = strdup(argv[3]);
  handle = strdup(argv[4]);
  
  if( socket_connect( &sockfd, ip_address) )
    {
      printf("Can't connect to the MW100 \"%s\".\n", ip_address);
      return 1;
    }

  if( get_modules( sockfd, modules) )
    {
      printf("Did not find MW100 at that IP address \"%s\".\n", ip_address);
      return 1;
    }
  
  shutdown( sockfd, SHUT_RDWR);
  close( sockfd);

  printf("MW100 unit found at %s\n", ip_address);
  for( i = 0; i < 6; i++)
    if( modules[i].use_flag)
      {
        printf("  slot %d: %s\n", i, modules[i].module_string);
      }
    else
      printf("  slot %d: empty\n", i);

  fptr_subst = fopen( "auto_mw100.substitutions", "w");
  fptr_req = fopen( "auto_mw100.req", "w");
  if( (fptr_subst == NULL) || (fptr_req == NULL) )
    {
      printf("\nERROR: Can't create output files.\n");
      fcloseall();
      return 1;
    }
  print_sf( fptr_subst, fptr_req, modules);

  fcloseall();

  return 0;
}

